package middleware

import (
	"bytes"
	"database/sql"
	"encoding/base64"
	"fsrv/src/config"
	"fsrv/src/database"
	"fsrv/src/database/entities"
	"fsrv/src/types/response"
	"fsrv/utils"
	"fsrv/utils/syncrl"
	"github.com/gin-gonic/gin"
	"github.com/zytekaron/gorl"
	"log"
	"math"
	"sync"
	"time"
)

// Rate limiting comment:
//  Due to only drawing from the authentication attempt bucket
//  when a key is verified to be invalid, a malicious client
//  could potentially send a large quantity of attempts to
//  authenticate simultaneously, without the attempt rate limit
//  kicking in immediately. This issue is mitigated by these:
//  - The server does not do a lot of work (a database query for
//    the key) if the key was not determined to be generated by
//    the server, as determined by the hash at the end of the key.
//  - Validating the key source is also a very fast operation, so
//    it is unlikely the client would be able to cause any database
//    queries unless they were using a key which had been generated
//    by the server but was then deleted or expired.

const urlRateLimitPurgeInterval = 10 * time.Minute

// UnifiedRateLimit
//
//	Middleware Dependencies:
//	 GetIP
//
//	Added Context Fields:
//	 key -> entities.Key (optional)
func UnifiedRateLimit(db database.DBInterface, serverCfg *config.Server) gin.HandlerFunc {
	anonRLManager := unifiedNewRL(serverCfg.IPAnonymousRL)
	attemptRLManager := unifiedNewRL(serverCfg.KeyAuthAttemptRL)
	defaultRLManager := unifiedNewRL(serverCfg.KeyAuthDefaultRL)

	keyRLSuite := syncrl.New()
	utils.Executor(urlRateLimitPurgeInterval, func() {
		anonRLManager.Purge()
		attemptRLManager.Purge()
		defaultRLManager.Purge()
		keyRLSuite.PurgeAll()
	})

	// checks whether the key was minted by the server.
	isValidKeyID := unifiedKeySourceValidator(
		serverCfg.KeyRandomBytes,
		serverCfg.KeyCheckBytes,
		[]byte(serverCfg.KeyValidationSecret),
	)

	// mutex to ensure multiple requests don't attempt
	// to add their own identical managers to the suite.
	var suiteModMux sync.Mutex

	return func(ctx *gin.Context) {
		ip := ctx.GetString("ip")

		// extract a key id from the request.
		keyID, ok := extractKey(ctx)
		if !ok {
			// no key provided: fallback to ip-based rate limiting.
			sb := anonRLManager.Get(ip)
			if !sb.Draw(1) {
				ctx.AbortWithStatusJSON(429, response.TooManyRequests)
				return
			}

			ctx.Next()
			return
		}

		// any further attempts are key validation attempts and
		// will penalize the user for providing an invalid key.
		attemptBucket := attemptRLManager.Get(keyID)

		// key provided: ensure the client has not exceeded
		// the allowed number of key authentication attempts.
		if !attemptBucket.CanDraw(1) {
			ctx.AbortWithStatusJSON(429, response.TooManyRequests)
			return
		}

		// ensure the key source is valid (generated by the server)
		// by checking if the key is properly suffixed with a hash.
		if !isValidKeyID(keyID) {
			ctx.AbortWithStatusJSON(403, response.Forbidden)
			return
		}

		// attempt to get the key from the database.
		key, err := db.GetKeyData(keyID)
		if err != nil {
			// if the key doesn't exist, draw from the attempt bucket.
			if err == database.ErrKeyMissing {
				attemptBucket.ForceDraw(1)
				ctx.AbortWithStatusJSON(403, response.Forbidden)
				return
			}

			log.Println("error getting key from database:", err)
			return
		}

		// ensure the key has not since expired.
		// if it has, draw from the attempt keyBucket.
		if key.IsExpired() {
			attemptBucket.ForceDraw(1)
			ctx.AbortWithStatusJSON(403, response.ForbiddenExpiredKey)
			return
		}

		// if the key doesn't specify a rate limit id,
		// use the default global ip-based one.
		if key.RateLimitID == "" {
			sb := anonRLManager.Get(ip)
			if !sb.Draw(1) {
				ctx.AbortWithStatusJSON(429, response.TooManyRequests)
				return
			}

			ctx.Next()
			return
		}

		// attempt to get a manager for the key's rate limit id.
		suiteModMux.Lock()
		keyBM, ok := keyRLSuite.Get(key.RateLimitID)
		if !ok {
			// one case per rate limit id: a manager does not exist. create one.
			rateLimit, err := db.GetRateLimitData(key.RateLimitID)
			if err != nil {
				// always an issue with the server. if the
				// rate limit doesn't exist, the issue is
				// caused by bad administration. otherwise,
				// a database issue was encountered.
				if err == sql.ErrNoRows {
					log.Println("missing rate limit in database with id:", key.RateLimitID)
				} else {
					log.Println("error getting rate limit from database:", err)
				}

				ctx.AbortWithStatusJSON(500, response.InternalServerError)
				return
			}

			// create and add a bucket manager instance for this rate limit level.
			keyBM = unifiedNewRL(rateLimit)
			keyRLSuite.Put(key.RateLimitID, keyBM)
		}
		suiteModMux.Unlock()

		// the key has passed validation checks.
		// get a rate limiting bucket for the key's own rate limit.
		keyBucket := keyBM.Get(keyID)

		// verify that the key has not exceeded its own rate limit.
		if !keyBucket.Draw(1) {
			ctx.AbortWithStatusJSON(429, response.TooManyRequests)
			return
		}

		// successful authentication: continue to next handler
		ctx.Next()
	}
}

func unifiedNewRL(rl *entities.RateLimit) *gorl.BucketManager {
	return gorl.New(rl.Limit, rl.Burst, time.Duration(rl.Refill))
}

func unifiedKeySourceValidator(randomBytes, checksumBytes int, salt []byte) func(string) bool {
	const b64repMlt float64 = 1 / (6.0 / 8) // base64 representation multiplier

	if checksumBytes > 64 {
		log.Fatal("unifiedKeySourceValidator: checksumBytes cannot be greater than 64 because sha512 produces 64 byte output")
	}

	size := int(math.Ceil(b64repMlt*float64(randomBytes)) + math.Ceil(b64repMlt*float64(checksumBytes)))

	return func(keyStr string) bool {
		if len(keyStr) != size {
			return false
		}

		key, err := base64.RawURLEncoding.DecodeString(keyStr)
		if err != nil {
			return false
		}

		data := key[:randomBytes]
		checksum := key[randomBytes:]

		sum := utils.Sha512Sum(data, salt) // sha512(data, salt)
		sum = sum[:checksumBytes]          // discard tail
		return bytes.Equal(checksum, sum)
	}
}
